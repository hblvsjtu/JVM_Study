# JVM_Study

## 作者：冰红茶  
## 参考书籍：《深入理解Java虚拟机》 周志明
    
------    
    
Java号称“Write once, run everywhere”，其中其重要作用莫过于他的虚拟机JVM。通过JVM可以了解到Java这种语言更加深层次的特点和运行状态以及内存分配。为后面为Java程序的高并发和性能优化打下坚实的基础^_ ^

## 目录
## [一、Java内存区域与内存溢出异常](#1)
### [1.1 运行时数据区域](#1.1)
### [1.2 HotSpot虚拟机对象探秘](#1.2)
### [1.3 OutOfMemoryError异常实战](#1.3)
## [二、垃圾收集器与内存分配策略](#2)
### [2.1 概述](#2.1)
### [2.2 判断对象存活](#2.2)

        
        
------      
        
<h2 id='1'>一、Java内存区域与内存溢出异常</h2>
<h3 id='1.1'>1.1 运行时数据区域</h3>  
        
#### 1) 概述
> - JVM一个突出的特点要数他的自动内存管理机制，不用为每一个new去写配对的delete/free代码
#### 2) 运行时数据区域
>>>>>> ![图1-1 运行时数据区](https://github.com/hblvsjtu/JVM_Study/blob/master/picture/%E5%9B%BE1-1%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png?raw=true)
#### 3) 程序计数器
> - 占用内存比较小，可以看作是当前所执行字节码的行号指示器。
> - 字节码解释器的工作是通过改变这个计数器的值来选择下一条所需要执行的字节码指令。继而进行分支，循环，跳转，异常处理等；
> - 在任意一个确定的时刻，一个内核只执行一条线程中的指令
> - “线程私有”内存 各条线程之间的计数器互不影响，独立存储计数器
> - Java方法和Native方法 前者记录的是字节码指令的地址，后者则为空Undefined，此区域是唯一一个JVM规范中没有规定任何OutOfMemoryError情况的区域
#### 4) Java虚拟机栈
> - 描述的是Java方法执行的内存模型
> - 线程私有
> - 执行的时候都会创建一个帧栈（Stack Frame），用于记录局部变量表（包括各种基本数据类型，对象引用）、操作数栈、动态链接、方法出口等信息
> - 一个方法的调用到执行完成，都对应着帧栈在虚拟机进栈和出栈的过程
> - 规定了两种异常
>> - StackOverflowError异常 线程请求的栈深度大于虚拟机所允许的深度
>> - OutOfMemoryError异常 虚拟机在拓展内存的时候无法申请到足够的内存
#### 5) 本地方法栈
> - 其实跟虚拟机栈很像，区别在于本地方法栈为虚拟机使用到的Native方法服务
> - 同样会有StackOverflowError异常和OutOfMemoryError异常
#### 6) Java堆
> - JVM管理内存中最大的一块
> - 被所有线程共享的一块内存区域，在虚拟机启动时创建
> - 此区域的唯一目的是存放实例对象，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器和逃逸技术的成熟，这不是那么绝对
> - 根据JVM的规定，Java堆可以处于物理不连续的内存空间中，只要逻辑上是连续的即可
> - 垃圾收集器管理的主要区域
#### 7) 方法区
> - 用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
> - 除了和Java堆一样不需要连续的内存区域和可以选择固定大小或者可拓展之外，还可以选择不实现垃圾收集
> - 可以抛出OutOfMemoryError异常
> - *运行时常量池（Runtime Constant Pool）*方法区的一部分 存放编译期生成的各种字面量和符号引用，相比Class文件常量池一个重要的特性是且具备动态性，主要是为了实行运行时常量
#### 8) 直接内存
> - 它并不是JVM运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域
> - 可以使用Native函数库直接分配堆外内存
> - 通过存储在Java堆中的FirectByteBuffer对象作为这块内存的引用进行操作。避免在Java堆和Native堆中来回复制数据
        
<h3 id='1.2'>1.2 HotSpot虚拟机对象探秘</h3>  
        
#### 1) 对象的创建
> - 检查在常量池中是否有该类的符号引用，并检查该类是否已经被加载、解析和初始化，如果没有，就先进行相应的类加载过程
> - 为新生对象在Java堆中的分配内存，内存的大小在类加载完成之后其实就已经完全确定。分配的方式有以下两种，使用哪一种方法主要看Java堆内存是否规整，而是否规整又是由垃圾收集器是否带有压缩整理的功能所决定
>> - “指针碰撞” 假设Java堆中是绝对规整的，所有用过的内存都放在一遍，空闲的放在另一边，中间靠一个指针作为分界点的指示器。那么分配内存是只是指针向空闲区域挪动一段与对象大小相等的距离
>> - “空闲列表” 跟指针碰撞相反，主要是应用于Java堆不规整的情况
> - 初始化
> - 对对象进行必要的设置，比如这个对下岗是那个类的实例，元数据信息，对象哈希码等信息存放在对象的对象头（Object Header）中
> - 执行new指令之后在执行< init>方法，按照程序员的医院进行初始化之后一个真正有用的对象才算完全产生出来
#### 2) 并发创建的注意问题
> - 对分配内存空间的动作进行同步处理
> - 给每个线程预先分配一个缓冲区，称为贝蒂线程分配缓冲（Thread Local Allocation Buffer，TLAB）。只有TLAB用完之后才进行同步锁定分配缓冲
#### 3) 对象的内存布局
> - 三个区域：对象头、实例数据（Instance Data）和对齐填充（Padding）
> - 对象头：分为两个部分
>> - 存储对象自身运行时的数据
>> - 类型指针 指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的对象
> - 实例数据 就是对象最重要的数据字段，存储的真正有效的数据
> - 对齐填充 要求对象的起始地址必须是8字节的整数倍，也就是说，对象也必须是8字节的整数倍，如果对象的数据。如果不对齐的话才需要对齐填充
#### 4) 对象的访问
> - 通过栈上的reference数据来操作堆上的数据
> - 句柄访问 Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。句柄中分别包含对象实例数据与类型数据各自的具体地址信息。好处是拥有稳定的句柄地址
> - 使用直接指针访问 跟句柄访问不同的是句柄中包含的直接就是对象地址，而对象实例数据中包含有到对象类型数据的指针。好处是速度快
> - 就Sun HotSpot而言，它是使用第二种方式——直接指针访问进行的。
        
<h3 id='1.3'>1.3 OutOfMemoryError异常实战</h3>  
        
#### 1) 对象的创建
> - 
> - 
> - 

        
        
------      
        
<h2 id=2>二、垃圾收集器与内存分配策略</h2>
<h3 id='2.1'>2.1 概述</h3>  
        
#### 1) 概述
> - 垃圾收集器所关注的是动态分配的内存
> - 一般来讲回收垃圾一般是回收新生代的垃圾，很少回收永久代的，但不是说就不回收，只是回收永久代（方法区）的效率很低
        
<h3 id='2.2'>2.2 判断对象存活</h3>  
        
#### 1) 引用计数算法
> - 给对象添加一个引用计数器，当被引用一次则加1，当引用失效的时候减1
> - 任何时刻计数器为0的对象就不可能在被引用
> - 意外的情况，互相引用造成GC无法回收
                
                a.instance = b;
                b.instance = a;
                a = null;
                b = null;
> - 但是在JVM中仍然被回收了，从侧面说明JVM并不是采用这种方式来判断对象是否存活
#### 2) 可达性分析算法
> - 通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始往下搜索，搜索走过的路径称为“引用链”
> - 当一个对象到GC Roots没有让你和引用链相连时，则证明该对象不可用
> - 可作为GC Roots的对象有
>> - 虚拟机栈（帧栈中的本地变量表）中引用的对象
>> - 方法区中类静态属性引用的对象
>> - 方法区中常量引用的对象（一般说的Native方法）引用的对象
#### 3) 再谈引用
> - JDK1.2后，Java扩充了引用的概念，以下四种引用强度依次逐渐减弱
> - 强引用 只要强引用在，GC永远不会回收掉所引用的对象，如
                
                Object obj = new Object();
> - 软引用 描述的是一些还有用但并非必需的对象，在下一次GC发生时，如果内存足够则不会被回收，否则在内存溢出前回收，如果回收后内存还不足够，才抛出内存溢出异常
> - 弱引用 在下一次GC发生时无论内存是否足够都会回收该关联的对象
> - 虚引用 虚引用对一个关联对象的生存时间不造成任何影响，也无法通过虚引用来取得一个对象实例，设置它的唯一目的是能在这个对象被GC的时会受到一个系统通知。
#### 4) 对象彻底执行死刑的条件
> - 如果一个对象被判定为可回收，那么它就判死刑了，但不是立即执行，它有可能转判为死缓
> - 真正要执行死刑的话需要满足三个条件：
>> - 对象覆写了finalize()方法
>> - 对象的finalize()方法没有被虚拟机调用过
>> - 第一次被标记进入自动建立的，低优先级的F－Queue队列，第二次没有逃脱被GC标记
#### ５) 无用的类
> - 该类所有实例都被回收
> - 加载该类的ClassLoader已经被回收
> - 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
        
<h3 id='2.3'>2.3 垃圾回收算法</h3>  
        
#### 1) 标记-清除算法
> - 